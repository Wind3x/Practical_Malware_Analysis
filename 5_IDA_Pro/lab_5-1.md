# Some Answers to A Lot of Questions

1. What is the address of DllMain?

> IDA automatically opens to DllMain in the .text section at address 0x1000D02E.

2. Use the Imports window to browse to gethostbyname. Where is the import located?

> The function gethostbyname is located in the .idata section at address 0x100163CC.

3. How many functions call gethostbyname?

> Using [x] to view all cross-references to the function gethostbyname, there are 18 references to this function (9 read 'r' references and 9 function call references denoted by 'p'). Looking at the list of sublinks that call gethostbyname, there are 5 unique memory addresses indicating 5 functions that call gethostbyname.

4. Focusing on the call to gethostbyname located at 0x10001757, can you figure out which DNS request will be made?

> gethostbyname accepts a single parameter, a character pointer, seen by hovering over the function name to show gethostbyname(const char \*name). A few instructions prior to the function call, we can see an offset link referencing data being moved into eax. Hovering over the offset link reveals the string "[This is RDO]pics.practicalmalwareanalysis.com". After the first mov instruction, we can see an add instruction for advancing the character pointer 0xD (13) bytes into the string before pushing eax onto the stack and calling the function. The function will therefore create a DNS request for "pics.practicalmalwareanalysis.com". 

5. How many local variables has IDA Pro recognized for the subroutine at 0x10001656?

> There are 23 variables with negative offsets, some of which IDA has automatically assigned names to.

6. How many parameters has IDA Pro recognized for the subroutine at 0x10001656?

> IDA has recognized a single argument with a positive offset, and named it lpThreadParameter.

7. Use the Strings window to locate the string \cmd.exe /c in the disassembly. Where is it located?

> In the xdoors\_d section at 0x10095B34 with one cross-reference where it is pushed onto the stack at 0x100101D0.

8. What is happening in the area of code that references \cmd.exe /c?

> Earlier in the function, we can see a lot of strings pushed onto the stack that include a welcome message, information about machine uptime and idle time, and 'Encrypt Magic Number For This Remote Shell Session'. After pushing the cmd.exe string, there is a series of memcmp operations checking for what seem to be various command strings such as 'inject', 'minstall', 'robotwork', etc. 

Hypothesis: This function handles interaction with a remote shell. 

9. In the same area, at 0x100101C8, it looks like dword\_1008E5C4 is a global variable that helps decide which path to take. How does the malware set dword\_1008E5C4? (Hint: Use dword\_1008E5C4â€™s cross-references.)

> Checking the cross-references to dword\_1008E5C4, we can see a single cross-reference of type 'w' that modifies the value. Jumping to this xref, we can see that the value is set by setting it equal to eax, which is the return value of the function called directly before in sub\_10003695. Navigating to this function in the disassembly, we can see that the eax register is cleared directly prior to a comparison between [ebp+VersionInformation.dwPlatformId] and the number 2. Looking this value up in MSDN,it represents "the operating system platform. This member can be VER\_PLATFORM\_WIN32\_NT (2)." So it appears that this function checks to see if the operating system is one of Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003, Windows XP, or Windows 2000. A following call to setz al will set al to 1 if the values are equal (likely). We can therefore assume that the value dword\_1008E5C4 will be set to 1. 

10. A few hundred lines into the subroutine at 0x1000FF58, a series of comparisons use memcmp to compare strings. What happens if the string comparison to robotwork is successful (when memcmp returns 0)?

> If the string comparison is successful, the function calls sub\_100052A2 which opens a registry key at "SOFTWARE\Microsoft\Windows\CurrentVersion" and queries the values for both "WorkTime" and "WorkTimes". These values are then sent via the sub\_100038EE function over the network SOCKET s ([ebp+s]). 

11. What does the export PSLIST do?

> The exported function first calls sub\_100036C3 to check the OS version, then proceeds to call the strlen function on a string (Str), a local variable which does not appear to be modified anywhere (presumably it's passed in when PSLIST is called). Depending on the outcome of the strlen function call, one of two functions are called, both of which seem to use a loop after calling CreateToolhelp32Snapshot. MSDN tells us this API function "Takes a snapshot of the specified processes, as well as the heaps, modules, and threads used by these processes." The function sub\_1000664C also includes a call to sub\_100038BB to send process information over the socket. The book claims that "both code paths return the process listing over the socket using *send*, however, I only noticed this in sub\_1000664C, the other branch which calls sub\_10006518 appears to write the process information to a file instead.

Hypothesis: The PSLIST export is used to enumerate processes on the host and either send the information remotely over a network socket or write it locally to a file.

12. Use the graph mode to graph the cross-references from sub\_10004E79. Which API functions could be called by entering this function? Based on the API functions alone, what could you rename this function?

> This function calls GetSystemDefaultLangID which, according to MSDN, "Returns the language identifier for the system locale." The function also include the previously seen 'send' function and another 'sprintf' API function. This function could be renamed to 'SendLangID' or similar.

13. How many Windows API functions does DllMain call directly? How many at a depth of 2?

> At a recursion depth of one, \_DllMain@12 cross-references 7 functions, 4 of which appear to be API functions. At a depth of two, there appears to be roughly 60 functions (maybe 32 API functions).

14. At 0x10001358, there is a call to Sleep (an API function that takes one parameter containing the number of milliseconds to sleep). Looking backward through the code, how long will the program sleep if this code executes?

> 1. A pointer to the string "[This is CTI]30" is moved into eax.
> 2. The instruction *add eax, 0Dh* advances the pointer by 13 bytes into the string, leaving the value in eax as "30".
> 3. eax is pushed onto the stack as the argument to the *atoi* function which converts "30" the string into 30 the integer.
> 4. *imul eax, 3E8h* performs signed multiplication of 30 and 3E8h (1000 in base 10). 
> 5. eax is pushed onto the stack as the argument to sleep, now at a value of 30,000 milliseconds or 30 seconds.

15. At 0x10001701 is a call to socket. What are the three parameters?

> Hovering over the socket function, we can see that it accepts three parameters - int af, int type, and int protocol. Prior to the function call, we see three values being pushed onto the stack, 6, 1, and 2 representing the protocol, type, and af respectively. Note the order is reversed due to the stack being a FILO data structure. Looking up these values in MSDN:
> * af = address family -> 2 = IPv4
> * type = socket type -> 1 = SOCK\_STREAM which is implemented via TCP
> * protocol = protocol-> 6 = TCP
>
> We can set symbolic constants for each of these values by right-clicking them and finding the appropriate listing for each in IDA's catalog. 

16. Using the MSDN page for socket and the named symbolic constants functionality in IDA Pro, can you make the parameters more meaningful? What are the parameters after you apply changes?

> (See 15)
> IPPROTO\_TCP, SOCK\_STREAM, and AF\_INET in the order they are pushed onto the stack.

17. Search for usage of the in instruction (opcode 0xED). This instruction is used with a magic string VMXh to perform VMware detection. Is that in use in this malware? Using the cross-references to the function that executes the in instruction, is there further evidence of VMware detection?

> The *in* instruction appears in sub\_10006196. Navigating to the function, we see *in eax, dx* with eax being set to *564D5868h* earlier. Toggling this hex value to ASCII shows that it is the string "VMXh". Navigating to a function that calls this function, we can see a path taken that includes a string "Found Virtual Machine,Install Cancel." indicating this is likely used for VMware detection.

18. Jump your cursor to 0x1001D988. What do you find?

> At this address, there appears to be a series of unreadable data (possibly obfuscated shellcode as seen previously in the chapter).

19. If you have the IDA Python plug-in installed (included with the commercial version of IDA Pro), run Lab05-01.py, an IDA Pro Python script provided with the malware for this book. (Make sure the cursor is at 0x1001D988.) What happens after you run the script?

> Running the script appears to decrypt a string by XORing each byte with 0x55. 

20. With the cursor in the same location, how do you turn this data into a single ASCII string?

> We can easily turn this data into an ASCII string by using [A] to toggle the data, making it more easily readable.

21. Open the script with a text editor. How does it work?

```
sea = ScreenEA() // grabs the effective address to use as the primary method of referencing

for i in range(0x00,0x50): // loop through the next 50 bytes
	b = Byte(sea+i)
	decoded_byte = b ^ 0x55 // XOR each byte with 0x55
	PatchByte(sea+i,decoded_byte) // modify the byte in the IDA display without changing the original file
```
